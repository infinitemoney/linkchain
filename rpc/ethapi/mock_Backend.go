// Code generated by mockery v1.0.0. DO NOT EDIT.

package ethapi

import (
	big "math/big"

	accounts "github.com/lianxiangcloud/linkchain/accounts"

	common "github.com/lianxiangcloud/linkchain/libs/common"

	context "context"

	evm "github.com/lianxiangcloud/linkchain/vm/evm"

	mock "github.com/stretchr/testify/mock"

	rpc "github.com/lianxiangcloud/linkchain/libs/rpc"

	rtypes "github.com/lianxiangcloud/linkchain/rpc/rtypes"

	state "github.com/lianxiangcloud/linkchain/state"

	types "github.com/lianxiangcloud/linkchain/types"

	vm "github.com/lianxiangcloud/linkchain/vm"
)

// MockBackend is an autogenerated mock type for the MockBackend type
type MockBackend struct {
	mock.Mock
}

// AccountManager provides a mock function with given fields:
func (_m *MockBackend) AccountManager() *accounts.Manager {
	ret := _m.Called()

	var r0 *accounts.Manager
	if rf, ok := ret.Get(0).(func() *accounts.Manager); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*accounts.Manager)
		}
	}

	return r0
}

// BalanceRecordByNumber provides a mock function with given fields: ctx, blockNr
func (_m *MockBackend) BalanceRecordByNumber(ctx context.Context, blockNr rpc.BlockNumber) (*types.BlockBalanceRecords, error) {
	ret := _m.Called(ctx, blockNr)

	var r0 *types.BlockBalanceRecords
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockNumber) *types.BlockBalanceRecords); ok {
		r0 = rf(ctx, blockNr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockBalanceRecords)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockNumber) error); ok {
		r1 = rf(ctx, blockNr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Block provides a mock function with given fields: heightPtr
func (_m *MockBackend) Block(heightPtr *uint64) (*rtypes.ResultBlock, error) {
	ret := _m.Called(heightPtr)

	var r0 *rtypes.ResultBlock
	if rf, ok := ret.Get(0).(func(*uint64) *rtypes.ResultBlock); ok {
		r0 = rf(heightPtr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rtypes.ResultBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*uint64) error); ok {
		r1 = rf(heightPtr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BlockByNumber provides a mock function with given fields: ctx, blockNr
func (_m *MockBackend) BlockByNumber(ctx context.Context, blockNr rpc.BlockNumber) (*types.Block, error) {
	ret := _m.Called(ctx, blockNr)

	var r0 *types.Block
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockNumber) *types.Block); ok {
		r0 = rf(ctx, blockNr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Block)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockNumber) error); ok {
		r1 = rf(ctx, blockNr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Coinbase provides a mock function with given fields:
func (_m *MockBackend) Coinbase() common.Address {
	ret := _m.Called()

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// ConsensusState provides a mock function with given fields:
func (_m *MockBackend) ConsensusState() (*rtypes.ResultConsensusState, error) {
	ret := _m.Called()

	var r0 *rtypes.ResultConsensusState
	if rf, ok := ret.Get(0).(func() *rtypes.ResultConsensusState); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rtypes.ResultConsensusState)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DumpConsensusState provides a mock function with given fields:
func (_m *MockBackend) DumpConsensusState() (*rtypes.ResultDumpConsensusState, error) {
	ret := _m.Called()

	var r0 *rtypes.ResultDumpConsensusState
	if rf, ok := ret.Get(0).(func() *rtypes.ResultDumpConsensusState); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rtypes.ResultDumpConsensusState)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EVMAllowed provides a mock function with given fields:
func (_m *MockBackend) EVMAllowed() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// GetBlock provides a mock function with given fields: ctx, blockHash
func (_m *MockBackend) GetBlock(ctx context.Context, blockHash common.Hash) (*types.Block, error) {
	ret := _m.Called(ctx, blockHash)

	var r0 *types.Block
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash) *types.Block); ok {
		r0 = rf(ctx, blockHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Block)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, common.Hash) error); ok {
		r1 = rf(ctx, blockHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockTokenOutputSeq provides a mock function with given fields: ctx, blockHeight
func (_m *MockBackend) GetBlockTokenOutputSeq(ctx context.Context, blockHeight uint64) map[string]int64 {
	ret := _m.Called(ctx, blockHeight)

	var r0 map[string]int64
	if rf, ok := ret.Get(0).(func(context.Context, uint64) map[string]int64); ok {
		r0 = rf(ctx, blockHeight)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]int64)
		}
	}

	return r0
}

// GetMaxOutputIndex provides a mock function with given fields: ctx, token
func (_m *MockBackend) GetMaxOutputIndex(ctx context.Context, token common.Address) int64 {
	ret := _m.Called(ctx, token)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) int64); ok {
		r0 = rf(ctx, token)
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// GetOutput provides a mock function with given fields: ctx, token, index
func (_m *MockBackend) GetOutput(ctx context.Context, token common.Address, index uint64) (*types.UTXOOutputData, error) {
	ret := _m.Called(ctx, token, index)

	var r0 *types.UTXOOutputData
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, uint64) *types.UTXOOutputData); ok {
		r0 = rf(ctx, token, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.UTXOOutputData)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, common.Address, uint64) error); ok {
		r1 = rf(ctx, token, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPoolNonce provides a mock function with given fields: ctx, addr
func (_m *MockBackend) GetPoolNonce(ctx context.Context, addr common.Address) (uint64, error) {
	ret := _m.Called(ctx, addr)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(context.Context, common.Address) uint64); ok {
		r0 = rf(ctx, addr)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, common.Address) error); ok {
		r1 = rf(ctx, addr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPoolTransaction provides a mock function with given fields: txHash
func (_m *MockBackend) GetPoolTransaction(txHash common.Hash) *types.Transaction {
	ret := _m.Called(txHash)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(common.Hash) *types.Transaction); ok {
		r0 = rf(txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	return r0
}

// GetPoolTx provides a mock function with given fields: txHash
func (_m *MockBackend) GetPoolTx(txHash common.Hash) types.Tx {
	ret := _m.Called(txHash)

	var r0 types.Tx
	if rf, ok := ret.Get(0).(func(common.Hash) types.Tx); ok {
		r0 = rf(txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.Tx)
		}
	}

	return r0
}

// GetReceipts provides a mock function with given fields: ctx, blockNr
func (_m *MockBackend) GetReceipts(ctx context.Context, blockNr uint64) types.Receipts {
	ret := _m.Called(ctx, blockNr)

	var r0 types.Receipts
	if rf, ok := ret.Get(0).(func(context.Context, uint64) types.Receipts); ok {
		r0 = rf(ctx, blockNr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.Receipts)
		}
	}

	return r0
}

// GetSeeds provides a mock function with given fields:
func (_m *MockBackend) GetSeeds() []rtypes.Node {
	ret := _m.Called()

	var r0 []rtypes.Node
	if rf, ok := ret.Get(0).(func() []rtypes.Node); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]rtypes.Node)
		}
	}

	return r0
}

// GetTransactionReceipt provides a mock function with given fields: hash
func (_m *MockBackend) GetTransactionReceipt(hash common.Hash) (*types.Receipt, common.Hash, uint64, uint64) {
	ret := _m.Called(hash)

	var r0 *types.Receipt
	if rf, ok := ret.Get(0).(func(common.Hash) *types.Receipt); ok {
		r0 = rf(hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Receipt)
		}
	}

	var r1 common.Hash
	if rf, ok := ret.Get(1).(func(common.Hash) common.Hash); ok {
		r1 = rf(hash)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(common.Hash)
		}
	}

	var r2 uint64
	if rf, ok := ret.Get(2).(func(common.Hash) uint64); ok {
		r2 = rf(hash)
	} else {
		r2 = ret.Get(2).(uint64)
	}

	var r3 uint64
	if rf, ok := ret.Get(3).(func(common.Hash) uint64); ok {
		r3 = rf(hash)
	} else {
		r3 = ret.Get(3).(uint64)
	}

	return r0, r1, r2, r3
}

// GetTx provides a mock function with given fields: hash
func (_m *MockBackend) GetTx(hash common.Hash) (types.Tx, *types.TxEntry) {
	ret := _m.Called(hash)

	var r0 types.Tx
	if rf, ok := ret.Get(0).(func(common.Hash) types.Tx); ok {
		r0 = rf(hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.Tx)
		}
	}

	var r1 *types.TxEntry
	if rf, ok := ret.Get(1).(func(common.Hash) *types.TxEntry); ok {
		r1 = rf(hash)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*types.TxEntry)
		}
	}

	return r0, r1
}

// GetTxsResult provides a mock function with given fields: ctx, blockNr
func (_m *MockBackend) GetTxsResult(ctx context.Context, blockNr uint64) (*types.TxsResult, error) {
	ret := _m.Called(ctx, blockNr)

	var r0 *types.TxsResult
	if rf, ok := ret.Get(0).(func(context.Context, uint64) *types.TxsResult); ok {
		r0 = rf(ctx, blockNr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TxsResult)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, uint64) error); ok {
		r1 = rf(ctx, blockNr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUTXOGas provides a mock function with given fields:
func (_m *MockBackend) GetUTXOGas() uint64 {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// GetVM provides a mock function with given fields: ctx, msg, _a2, header, vmCfg
func (_m *MockBackend) GetVM(ctx context.Context, msg types.Message, _a2 *state.StateDB, header *types.Header, vmCfg evm.Config) (vm.VmInterface, func() error, error) {
	ret := _m.Called(ctx, msg, _a2, header, vmCfg)

	var r0 vm.VmInterface
	if rf, ok := ret.Get(0).(func(context.Context, types.Message, *state.StateDB, *types.Header, evm.Config) vm.VmInterface); ok {
		r0 = rf(ctx, msg, _a2, header, vmCfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(vm.VmInterface)
		}
	}

	var r1 func() error
	if rf, ok := ret.Get(1).(func(context.Context, types.Message, *state.StateDB, *types.Header, evm.Config) func() error); ok {
		r1 = rf(ctx, msg, _a2, header, vmCfg)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(func() error)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, types.Message, *state.StateDB, *types.Header, evm.Config) error); ok {
		r2 = rf(ctx, msg, _a2, header, vmCfg)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// HeaderByNumber provides a mock function with given fields: ctx, blockNr
func (_m *MockBackend) HeaderByNumber(ctx context.Context, blockNr rpc.BlockNumber) (*types.Header, error) {
	ret := _m.Called(ctx, blockNr)

	var r0 *types.Header
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockNumber) *types.Header); ok {
		r0 = rf(ctx, blockNr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Header)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockNumber) error); ok {
		r1 = rf(ctx, blockNr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetInfo provides a mock function with given fields:
func (_m *MockBackend) NetInfo() (*rtypes.ResultNetInfo, error) {
	ret := _m.Called()

	var r0 *rtypes.ResultNetInfo
	if rf, ok := ret.Get(0).(func() *rtypes.ResultNetInfo); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rtypes.ResultNetInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PrometheusMetrics provides a mock function with given fields:
func (_m *MockBackend) PrometheusMetrics() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ProtocolVersion provides a mock function with given fields:
func (_m *MockBackend) ProtocolVersion() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// SendTx provides a mock function with given fields: ctx, signedTx
func (_m *MockBackend) SendTx(ctx context.Context, signedTx types.Tx) error {
	ret := _m.Called(ctx, signedTx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.Tx) error); ok {
		r0 = rf(ctx, signedTx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StartTheWorld provides a mock function with given fields:
func (_m *MockBackend) StartTheWorld() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// StateAndHeaderByNumber provides a mock function with given fields: ctx, blockNr
func (_m *MockBackend) StateAndHeaderByNumber(ctx context.Context, blockNr rpc.BlockNumber) (*state.StateDB, *types.Header, error) {
	ret := _m.Called(ctx, blockNr)

	var r0 *state.StateDB
	if rf, ok := ret.Get(0).(func(context.Context, rpc.BlockNumber) *state.StateDB); ok {
		r0 = rf(ctx, blockNr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.StateDB)
		}
	}

	var r1 *types.Header
	if rf, ok := ret.Get(1).(func(context.Context, rpc.BlockNumber) *types.Header); ok {
		r1 = rf(ctx, blockNr)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*types.Header)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, rpc.BlockNumber) error); ok {
		r2 = rf(ctx, blockNr)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Stats provides a mock function with given fields:
func (_m *MockBackend) Stats() (int, int, int) {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 int
	if rf, ok := ret.Get(1).(func() int); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(int)
	}

	var r2 int
	if rf, ok := ret.Get(2).(func() int); ok {
		r2 = rf()
	} else {
		r2 = ret.Get(2).(int)
	}

	return r0, r1, r2
}

// Status provides a mock function with given fields:
func (_m *MockBackend) Status() (*rtypes.ResultStatus, error) {
	ret := _m.Called()

	var r0 *rtypes.ResultStatus
	if rf, ok := ret.Get(0).(func() *rtypes.ResultStatus); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rtypes.ResultStatus)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopTheWorld provides a mock function with given fields:
func (_m *MockBackend) StopTheWorld() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// SuggestPrice provides a mock function with given fields: ctx
func (_m *MockBackend) SuggestPrice(ctx context.Context) (*big.Int, error) {
	ret := _m.Called(ctx)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(context.Context) *big.Int); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Validators provides a mock function with given fields: heightPtr
func (_m *MockBackend) Validators(heightPtr *uint64) (*rtypes.ResultValidators, error) {
	ret := _m.Called(heightPtr)

	var r0 *rtypes.ResultValidators
	if rf, ok := ret.Get(0).(func(*uint64) *rtypes.ResultValidators); ok {
		r0 = rf(heightPtr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rtypes.ResultValidators)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*uint64) error); ok {
		r1 = rf(heightPtr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
